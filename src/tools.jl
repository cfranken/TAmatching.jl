const global options = ["Geology", "Geophysics", "Geobiology", "Geochemistry", "Planetary Science", "ESE"] 

# find matching names, return matching score and index
function matchNames(student_name,fac_names)
    mc  = 0
    bestMatch = "" # best match!
    subname = split(strip(student_name)," ")
    for s in fac_names
        cc = 0
        fac_sub = split(strip(s)," ")
        for sub in lowercase.(subname), subf in lowercase.(fac_sub)
            # Could use regex or something, just being lazy...
            cc += occursin(sub, subf)
            cc += occursin(subf, sub)
        end
        if cc > mc
            mc = cc
            bestMatch = s
        end
    end
    return mc, bestMatch
end

"Load student table generated by Julie"
function loadStudents(xlsFile)
    students = Dict()
    for option in options
        students[option] = DataFrame(XLSX.readtable(xlsFile, option)...)
    end
    return students
end

"Check student submissions"
function checkStudents(students, submissions, thresh=3)
    for option in options
        for i = 1:size(students[option],1)
            foundEmail = students[option]."Email"[i] in submissions."Email Address"
            if !foundEmail
                # Try matching names:
                sName = students[option]."Student Name"[i]
                mc, bestMatch = matchNames(sName,submissions."Your Name")
                if mc<thresh
                    println(option, ": ", sName,  " ", students[option]."Year Of Study"[i], " , matchScore: ", mc, ", Best match: ", bestMatch )
                end
            end
        end
    end
end 

"find matches for students (for a class and whether faculty and students matched in preference)"
function find_matched_students(df_classes, df_students, row, course)
    ind_matched = findall(df_classes."Class Name".==row[FacTA_class[course]])[1]
    #println(ind_matched)
    df_classes[ind_matched,3] = "X"
    #println("Selectable candidates (chosen by faculty): ", row[FacTA_student[course]])
    students = split(row[FacTA_student[course]],",")
    # @show students
    #println("Student Choices (Name, PriorityRank)")
    for a in keys(StuClass)
        matchedStudent = filter(df -> df[StuClass[a]]  == row[FacTA_class[course]], dropmissing(df_students, StuClass[a]))
        for i=1:size(matchedStudent,1)
            sName = matchedStudent[!,:"Your Name"][i]
            matches, _ = matchNames(sName,students)
            #@show sName

            if matches>1
                if df_classes[ind_matched,4] == ""
                    df_classes[ind_matched,4] = df_classes[ind_matched,4] *  sName
                else
                    df_classes[ind_matched,4] = df_classes[ind_matched,4] *  ", " * sName 
                end

                #println(sName, " ", matchedStudent[!,StuInterest[a]][i], ", NameMatches: ", matches)
            else
                if df_classes[ind_matched,5] == ""
                    df_classes[ind_matched,5] = df_classes[ind_matched,5]  * sName
                else
                    df_classes[ind_matched,5] = df_classes[ind_matched,5]  * ", " * sName
                end

            end
        end
    end
end

"find matches for students (for a class, with faculty input missing)"
function find_matched_students(df_classes, df_students, class)
    ind_matched = findall(df_classes."Course".==class)[1]
    println("")
    #println(ind_matched)
    #df_classes[ind_matched,3] = "O"
    for a in keys(StuClass)
        matchedStudent = filter(df -> occursin(lowercase(class), lowercase(df[StuClass[a]])), dropmissing(df_students, StuClass[a]))
        for i=1:size(matchedStudent,1)
            sName = matchedStudent[!,:"Your Name"][i]
            iName = 2 + (i-1)*2
            df_classes[ind_matched,iName] = sName
        end
    end
    println("########################")
end

# Compute matching score as a mix of student and faculty preferences:
function match_score(class::gps_class)
    matches = class.matching
    score = zeros(length(matches))
    for iMatch in eachindex(matches)
        score[iMatch] = match_score(class, matches[iMatch])
    end
    #println(score)
    return score
end

function match_score(class::gps_class, student; penalty=2)
    ind = findall(x->!ismissing(x) && x==class.name, student.class_list)
    all = mean(skipmissing(student.class_preference))
    if length(ind) > 0
        ind = ind[1]
        # Here, the score by the student is added (max is 5):
        ismissing(student.class_preference[ind]) ? score = 1 : score = student.class_preference[ind] 
        # Now the preference by the class owner (max is 5):
        ind = findall(x->x==student.name, class.orig_student_list)
        # if not in list, remove offset from score
        if length(ind)==0
            score -= penalty
        else # score 
            l = length(class.orig_student_list)
            if l>1
                sc = range(2,1,length=l)
                score += sc[ind[1]]
            else
                score += 5
            end
        end

        #length(ind)>0 ? ind=ind[1] : ind=length(class.orig_student_list) + offset
        #score += (5 - 4*(ind-1)/7)
        # length(class.orig_student_list))
        return score
    else
        return -100.0
    end
end

function student_match(class::gps_class, student)
    # Now the preference by the class owner (max is 5):
    ind = findall(x->x==student.name, class.orig_student_list)
    
    if length(ind)==0
        return false
    else # score 
        return true
    end
end

# add matching student and sort by score:
function addMatch(class::gps_class, student::gps_student)
    if length(getIndex(student.name,class.matching)) == 0
        push!(class.matching, student)
        scores = match_score(class)
        sortedIndex = sortperm(scores,rev=true)
        class.matching[:] = class.matching[sortedIndex]
        class.matchingScore = scores[sortedIndex]
        return sortedIndex[end]
    else
        println(student.name, " is already in class match list")
        return -1
    end
end

# Remove student:
function removeMatch(class::gps_class, student::gps_student)
    indDel = findall(x->x.name == student.name,class.matching)
    deleteat!(class.matching, indDel )
    deleteat!(class.matchingScore, indDel )
end

# Remove last student in list:
function removeLast(class::gps_class)
    pop!(class.matchingScore)
    return pop!(class.matching)
end

function matchName(class::gps_class,students)
    for student in students, iClass in student.class_list
        if !ismissing(iClass) && iClass == class.name
            if sum(occursin.(student.name,class.student_list)) ≥ 1
                println(class.name, " ", student.name  )
                addMatch(class, student)
            end
        end
    end
end

function getIndex(name, list)
    ind = findall(x->x.name==name, list)
    if length(ind) > 1
        @info "Multiple indices", ind
    end
    if length(ind)<1
        return []
    else
        return ind[1]
    end
end

function matchName(student::gps_student,classes)
    classFound = false
    for class in classes
        if sum(occursin.(student.name,class.student_list)) ≥ 1
            #println(class.name, " ", student.name  )
            classFound = true
        end
    end
    if !classFound
        println("No Match ",student.name, " ", student.graduate, " ", classFound)
    end
end
